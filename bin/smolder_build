#!/usr/bin/env perl
use warnings;
use strict;

=pod

=head1 NAME

smolder_build 

build a Smolder binary distribution from source

=head1 SYNOPSIS

To automatically determine the platform:

  smolder_build

Or specify it explicitely:

  smolder_build [platform]

=head1 DESCRIPTION

This script builds Smolder from source for the specified platform.  In
most cases you must be running the platform for which you're building
(i.e. no cross-compilation).

Available platforms are the set of directories in F<platform/>.

=head1 OPTIONS

The script takes the following options:

=over

=item --no-apache

By default the script will build apache and mod_perl for you.  This
option skips those steps.

=item --mysql

By default Smolder will use SQLite. If for some reason this bothers
you (or you want to use this data from other machines) then it can
also be built to use MySQL.

=item --module

Specify a specific CPAN module to build.  The string you provide will
be checked as a substring against the distribution file name. You can 
specify this option multiple times to build a specific set of modules.

When this is specified it automatically sets C<no-apache>
to true.

=item --skip-module

Same as C<module> above, but skips the specified modules and builds
everything else.  
The C<--module>, C<--skip-module> and C<--no-module>
options are not intended to be used together.

=item --no-modules

This option is similar to C<--skip-module> except that it skips every
perl module.
The C<--module>, C<--skip-module> and C<--no-module>
options are not intended to be used together.

=item --debug

This option will build Apache and mod_perl with debugging symbols
turned on.
This is extremely useful for tracking down segmentation faults.

=item --dev

This will build a series of optional modules that help developers in
the creation and maintenence of Smolder.

=item --help

=item --man

=cut

use File::Spec::Functions qw(catdir catfile splitdir rel2abs);
use FindBin qw($RealBin);
use Config;

BEGIN {

    # Find a SMOLDER_ROOT based on path to bin
    my @dir = splitdir($RealBin);

    #remove any blank elements on the end of the @dir
    pop(@dir) while ( !$dir[$#dir] );
    $ENV{SMOLDER_ROOT} ||= catdir( @dir[ 0 .. $#dir - 1 ] );

    # use SMOLDER_ROOT/lib for modules
    my $lib = catdir( $ENV{SMOLDER_ROOT}, "lib" );
    $ENV{PERL5LIB} =
      $ENV{PERL5LIB}
      ? "$ENV{PERL5LIB}:${lib}"
      : "${lib}";
    unshift @INC, $lib, "$lib/" . $Config{archname};

    # add in $SMOLDER_ROOT/platform for platform build modules
    my $plib = catdir( $ENV{SMOLDER_ROOT}, "platform" );
    $ENV{PERL5LIB} = "$ENV{PERL5LIB}:${plib}";
    unshift @INC, $plib;
}
use Pod::Usage;
use Getopt::Long;
use File::Temp qw(tempdir);
use Smolder::Platform;

# setup path variables
my $ROOT            = $ENV{SMOLDER_ROOT};
my $SRC_DIR         = catdir( $ROOT, 'src' );
my $DEST_DIR        = catdir( $ROOT, 'lib' );
my $APACHE_DEST_DIR = catdir( $ROOT, 'apache' );
my $BUILD_DIR       = tempdir( DIR => catdir( $ROOT, 'tmp' ) );
my $PLATFORM_DIR    = catdir( $ROOT, 'platform' );

# a few useful constants
my $APACHE       = 'Apache-MOD_PERL/apache_1.3.36.tar.gz';
my $MOD_PERL     = 'Apache-MOD_PERL/mod_perl-1.29.tar.gz';
my $LIBAPREQ     = 'libapreq';
my $APACHE_TEST  = 'Apache-Test';

# options
my $skip_apache  = 0;
my $build_mysql  = 0;
my $skip_modules = 0;
my $dev          = 0;
my ( @modules, @skip_modules, $help, $man, $debug );
GetOptions(
    'no-apache'     => \$skip_apache,
    'mysql'         => \$build_mysql,
    'no-modules'    => \$skip_modules,
    'module=s'      => \@modules,
    'skip-module=s' => \@skip_modules,
    'help'          => \$help,
    'man'           => \$man,
    'debug'         => \$debug,
    'dev'           => \$dev,
) or pod2usage(2);

pod2usage(1) if $help;
pod2usage( -verbose => 2 ) if $man;

# don't build the extra stuff if we just want to build Perl modules
if (@modules) {
    $skip_apache = 1;
}

# get platform arg
pod2usage("Wrong number of arguments.\n") if @ARGV > 1;
my $platform;

my $pkg;
if (@ARGV) {
    $platform = shift;
    eval { $pkg = Smolder::Platform->load($platform) };
    if ( $@ ) {
        die "Platform '$platform' is not supported.  "
          . "Available platforms are:\n\n\t"
          . join( "\n\t", @Smolder::Platform::PLATFORMS ) . "\n\n";
    }
} else {

    # look for a platform that wants to handle this
    $pkg = Smolder::Platform->load();
    die "Unable to automatically determine your platform, you must\n"
      . "provide one on the command line.  Available platforms are:\n\n\t"
      . join( "\n\t", @Smolder::Platform::PLATFORMS ) . "\n\n"
      unless $pkg;

    # set the platform
    $pkg =~ /(.*)::Platform$/;
    $platform = $1;
}

# verify the platform
$pkg->verify_dependencies( mode => 'build', no_mysql => !$build_mysql );

# get list of files to build, considering --module and --skip-module opts
opendir( SRC, $SRC_DIR ) or die "Can't open $SRC_DIR for reading: $!";
my @files = sort readdir(SRC);

unless ($skip_modules) {

    if (@modules) {
        @files = grep { contains( \@modules, $_ ) } @files;
    
        # don't skip the Perl modules related to the external stuff
        # if we specifically specify the module
        $build_mysql = 1 if( grep { $_ =~ /mysql/i } @modules );

    } elsif (@skip_modules) {
        @files = grep { !contains( \@skip_modules, $_ ) } @files;
    }

    # shuffle these modules to the back to get proper build order
    foreach my $dist ($pkg->last_perl_modules) {
        my ($file) = grep( /$dist/, @files );
        @files = grep( !/$dist/, @files );
        push @files, $file if $file;
    }

    # shuffle these modules to the front since they're needed by later build steps
    foreach my $dist ($pkg->first_perl_modules) {
        my ($file) = grep( /\Q$dist\E/, @files );
        @files = grep( !/\Q$dist\E/, @files );
        unshift @files, $file if $file;
    }

    # remove these complete since our platform doesn't need them
    foreach my $dist ($pkg->skip_perl_modules) {
        @files = grep( !/\Q$dist\E/, @files );
    }

    # remove these if we aren't in dev mode
    if( !$dev ) {
        foreach my $dist ($pkg->dev_perl_modules) {
            @files = grep( !/\Q$dist\E/, @files );
        }
    }

    # loop through files, unpacking and calling build_perl_module()
    foreach my $file (@files) {
        next unless $file =~ /gz$/;

        # wait to build libapreq and Apache::Test til we've built Apache
        next if $file =~ /^$LIBAPREQ/o;
        next if $file =~ /^$APACHE_TEST/o;

        # skip modules that we need to skip based on skipping external libs
        # but we still need DateTime::Format::MySQL since it works under sqlite too
        next if (!$build_mysql && $file =~ /mysql/i  && $file !~ /DateTime-Format-MySQL/i);

        build_module($file);
    }
}

# build Apache/mod_perl
unless ($skip_apache) {
    goto_build_dir();

    my $apache_gz = catfile( $SRC_DIR, $APACHE );
    system("tar zxf $apache_gz") == 0 or die "Couldn't unpack file: $?";
    my ($apache_dir) = $apache_gz =~ m{/([^/]+)\.tar\.gz$};
    die "Can't find Apache dir '$apache_dir'." unless -d $apache_dir;

    my $mod_perl_gz = catfile( $SRC_DIR, $MOD_PERL );
    system("tar zxf $mod_perl_gz") == 0 or die "Couldn't unpack file: $?";
    my ($mod_perl_dir) = $mod_perl_gz =~ m{/([^/]+)\.tar\.gz$};
    die "Can't find Mod_perl dir '$mod_perl_dir'." unless -d $mod_perl_dir;

    $pkg->build_apache_modperl(
        apache_dir       => $apache_dir,
        mod_perl_dir     => $mod_perl_dir,
        debug            => $debug,
    );

    # build Apache::Test before libapreq but after apache
    if( my ($apache_test) = grep /^$APACHE_TEST/, @files ) {
        build_module($apache_test);
    }

    # build libapreq now that mod_perl is in place
    if ( my ($libapreq) = grep /^$LIBAPREQ/, @files ) {
        build_module($libapreq, debug => $debug);
    }
}

# drop a build.db file describing the build, used by smolder_makedist
# and smolder_install
my @db_plats;
push(@db_plats, 'MySQL') if $build_mysql;
push(@db_plats, 'SQLite');

print "Writing data/build.db\n";
open( DB, '>', catfile( $ENV{SMOLDER_ROOT}, 'data', 'build.db' ) )
  or die "Unable to open 'data/build.db': $!";
print DB "Platform $platform\n";
print DB sprintf "Perl \"%d.%d.%d\"\n", ( map { ord($_) } split( "", $^V, 3 ) );
print DB "Arch \"$Config{archname}\"\n";
if( @db_plats ) {
    print DB "DBPlatforms " . join(', ', @db_plats);
    print DB "\n";
}
print DB "Dev $dev\n";
close DB;

# all done, cleanup build dir
print "Cleaning temporary build directory $BUILD_DIR.\n";

rmdir($BUILD_DIR);

print "\n\nBuild complete!\n";

#
# Subroutines
#

# unpack a distribution and use the platform module to build it
sub build_module {
    my $file = shift;

    # unpack distribution
    my $dist_file = catfile( $SRC_DIR, $file );
    print "Unpacking $dist_file...\n";
    goto_build_dir();
    system("tar zxf $dist_file") == 0 or die "Couldn't unpack file: $?";

    $dist_file =~ m!([^/]+)\.(tar\.|t)gz!;
    my $dist_dir = $1;

    die "Can't determine dist_dir for '$dist_file'." unless $dist_dir;
    chdir $dist_dir or die "Unable to chdir($dist_dir): $!";

    eval { $pkg->build_perl_module( name => $dist_dir ); };
    die "Problem building $dist_dir in $BUILD_DIR:\n\n$@\n"
      if $@;

    # clean up dist dir
    system("rm -rf $dist_dir") == 0 or die "Error cleaning $dist_dir: $?";
}

sub goto_build_dir {
    chdir $BUILD_DIR or die "Unable to chdir($BUILD_DIR): $!";
}

# returns true if list contains a string which contains the target string
sub contains {
    my ( $list, $string ) = @_;
    $string =~ s/::/-/g;    # allow '::' to be used instead of '-'
    return grep { index( $string, $_ ) > -1 } @{$list};
}

# print all those nice asterisks
sub print_message {

    print "\n\n************************************************\n\n", shift,
      "\n\n************************************************\n\n";
}
