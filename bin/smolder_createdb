#!/usr/bin/perl 
use warnings;
use strict;

=pod

=head1 NAME

smolder_createdb

=head1 SYNOPSIS

Create the database for smolder.

=head2 For MySQL

Provide the MySQL root password, required if MySQL is configured to
need one:

   smolder_createdb --password foobar

=head2 By Hand

If root access to the database is not directly available, you can instead print
out the commands needs, and give them to someone with access to run manually.

   smolder_createdb --dry_run

=head1 DESCRIPTION

Creates databases using information in F<smolder.conf>.

=head1 OPTIONS

The script takes the following options:

=over

=item --dry_run 

Simply print the commands that would be run, but don't actually run them. 
Useful when root access is not directly available. 

=item --destroy

By default the script only creates databases if they do not already
exist.  This option tells smolder_createdb to destroy the database
first.  You will be prompted to confirm your dangerous request.

=item --no_create

Do not create new databases.  Can be useful if used in conjunction with
--destroy.

=item --no_prompt

Do not prompt user for confirmation on any events

=item --password [pass]

If you configured your database to require a root password then you'll need to
provide it here.

=item --hostname [host]

If you are running MySQL on another host then you'll need to
provide it here.

=item --ip_address [addr] 

IP address of host connecting to the database server. (Usually this matchine).
By default we use the value of C<ApacheAddr> from <smolder.conf>, which
defaults to C<127.0.0.1>. Connections to the smolder database will be allowed
only from this machine.

=item --verbose

Once gives you a play-by-play. Twice gets you full SQL.

=item --help

=item --man

=back

=cut

use File::Spec::Functions qw(catdir catfile splitdir rel2abs canonpath);
use FindBin qw($RealBin);
use Config;

BEGIN {

    # Find a SMOLDER_ROOT based on path to bin
    my @dir = splitdir( canonpath($RealBin) );
    $ENV{SMOLDER_ROOT} ||= catdir( @dir[ 0 .. $#dir - 1 ] );

    # use $SMOLDER_ROOT/lib for modules
    my $lib = catdir( $ENV{SMOLDER_ROOT}, "lib" );
    $ENV{PERL5LIB} =
      $ENV{PERL5LIB}
      ? "$ENV{PERL5LIB}:${lib}"
      : "${lib}";
    unshift @INC, $lib, "$lib/" . $Config{archname};

    # load Smolder
    eval { require Smolder };
    warn << "END" and exit(1) if $@;
######################################################################

Cannot load Smolder.

Error message:

$@

######################################################################
END
}

use Term::Prompt qw(prompt);
use Smolder::Conf qw(InstallRoot DBDriver DBName DBUser DBPass DBHost ApacheAddr);

use Getopt::Long;
use Pod::Usage;
# made available by smolder_build 
use DBIx::DBH;

my $help           = 0;
my $man            = 0;
my $admin_password = '';
my $ip_address     = ApacheAddr;
my $hostname       = DBHost;
my $db_driver      = DBDriver || 'mysql';
my $db_name        = DBName;
my $db_user        = DBUser;
my $db_pass        = DBPass;
my $destroy        = 0;
my $no_prompt      = 0;
my $no_create      = 0;
my $verbose        = 0;
my $dry_run        = 0;

GetOptions(
    'help'       => \$help,
    'man'        => \$man,
    'verbose+'   => \$verbose,
    'dry_run'    => \$dry_run, 
    'destroy'    => \$destroy,
    'no_prompt'  => \$no_prompt,
    'no_create'  => \$no_create,
    'password=s' => \$admin_password,
    'hostname=s' => \$hostname,
    'ip_address=s' => \$ip_address,
  )
  or pod2usage(2);
pod2usage(1) if $help;
pod2usage( -verbose => 2 ) if $man;

our %DB_User = (
    driver   => $db_driver, 
    dbname   => DBName,
    user     => $db_user,
    password => $db_pass, 
    host     => $hostname,
);
# For SQLite, turn the DB name into a file path. 
$DB_User{dbname} = catdir($ENV{SMOLDER_ROOT}, 'data', DBName) if ($db_driver eq 'SQLite');

our %DB_Root = (
    %DB_User, 
    user     => 'root',
    password => $admin_password,
);

# create re-usable, package scope handles
our ($User_DBH, $Root_DBH);
DBI->trace(1) if $verbose > 1;

if ($dry_run) {
    print "-- This is a DRY RUN. No SQL is actually being executed.\n";
    print "-- These commands need to be run by the root database user\n";
}

if (not $dry_run) {
    # make sure DB is accessible. 
    $Root_DBH = DBIx::DBH->connect(%DB_Root);

    my $output = $Root_DBH->errstr;
    unless ( $Root_DBH ) {
        if ( $output =~ /Access denied/ ) {
            if ( defined $admin_password ) {
                my $msg = "database root password '$admin_password' is not valid";
                $msg .= "for this host '$hostname'.\n" if defined $hostname;
                die($msg);
            } else {
                my $msg =
                    "Unable to connect to database as root with no password.  "
                  . "Maybe you need to use --password?";
                $msg .= " or --hostname?" if not defined $hostname;
                $msg .= "\n";
                die($msg);
            }
        } else {
            die("Unable to access database. The error returned was:\n$output\n");
        }
    }
}

# leave no database standing
if ($destroy) {

    # make sure they really meant --destroy
    if ((not $no_prompt) and (not $dry_run)) {
        exit 1
          unless prompt(
            "y",
            "This program will drop and recreate Smolder the database \n"
              . "for this installation.\n\nAre you sure you want to proceed?",
            "y/n",
            "y"
          );
    }

    print STDERR "Dropping database '$db_name'...\n" if $verbose;

    my $Root_DBH ||= DBIx::DBH->connect(%DB_Root);
    my $dropdb_cmd = "DROP DATABASE IF EXISTS $db_name'";
    if ($dry_run) {
        print "$dropdb_cmd\n"
    }
    else {
        print "Running '$dropdb_cmd'\n" if $verbose > 1;
        $Root_DBH->do($dropdb_cmd) || die "Couldn't drop database $db_name: $?";
    }
}

exit 0 if $no_create;

# skip if database exists
my $db_exists_cmd = qq{select "$db_name exists"};
print "Running '$db_exists_cmd'\n" if $verbose > 1;

my $db_exists_result;
if (not $dry_run) {
    $User_DBH ||= DBIx::DBH->connect(%DB_User);
    ($db_exists_result) = $User_DBH->selectrow_array($db_exists_cmd);
}

# if the database already exists
if (($db_exists_result =~ /$db_name exists/)) {
    print "Database '$db_name' already exists, skipping create.\n";

    # else create the database
} else {
    print STDERR "Creating database '$db_name'...\n" if $verbose;
    my $createdb_cmd = "CREATE DATABASE $db_name;";
    if ($dry_run) {
        print "$createdb_cmd\n";
    }
    else {
        print "Running '$createdb_cmd'\n" if $verbose > 1;
        $Root_DBH ||= DBIx::DBH->connect(%DB_Root);
        $Root_DBH->do($createdb_cmd) || die "Couldn't create database: $?";
    }

    # grant access to the database to DBUser 
    if (DBDriver eq 'mysql') {
        my $grant_cmd = qq{grant all on $db_name.* to "$db_user";};

        # If we have a remote connection to MySQL restrict connections by IP. 
        my $connect_from_host = (defined $hostname) ? $ip_address : "localhost";

        $grant_cmd .= qq{\@'$connect_from_host'};
        $grant_cmd .= qq{ identified by "$db_pass" } if $db_pass;
        $grant_cmd .= "'";
        if ($dry_run) {
            print "$grant_cmd\n";
        }
        else {
            print "Running '$grant_cmd'\n" if $verbose > 1;
            $Root_DBH ||= DBIx::DBH->connect(%DB_Root);
            $Root_DBH->do($grant_cmd) || die "Couldn't grant all: $?";
        }
    }

    if ($dry_run) {
        print "-- these SQL commands can be run by $db_user\n";
    }

    # load all sql files as the DBUser
    # Non-MySQL drivers are stored in subdirs based on their driver name.
    my $driver_subdir = DBDriver unless (DBDriver eq 'mysql');
    my $sql_dir = catdir( InstallRoot, 'sql', $driver_subdir );
    my $DIR;
    opendir( $DIR, $sql_dir ) or die "Could not open $sql_dir for reading! $!";
    while ( my $file = readdir($DIR) ) {
        next if $file =~ /^\./;    # parental controls
        next if $file !~ /\.sql$/; # only SQL files
        $file = catfile( $sql_dir, $file );

        print STDERR "Loading SQL for '$db_name' from $file...\n" if $verbose;

        # Slurp the file. 
        my $sql = do { local( @ARGV, $/ ) = $file ; <> } ;

        if ($dry_run) {
            print "$sql\n";
        }
        else {
            print "Running '$sql'\n" if $verbose > 1;
            $User_DBH ||= DBIx::DBH->connect(%DB_User);
            # Maybe some drivers will barf on more than one command per "do"?
            $User_DBH->do($sql) || die "Couldn't load SQL: $?: $!";
        }
    }

    # Set the db_version
    my $version = $Smolder::VERSION;
    my $update_ver_cmd = qq{UPDATE db_version set db_version=$version';};
    if ($dry_run) {
        print "$update_ver_cmd\n";
    }
    else {
        print "Running '$update_ver_cmd'\n" if $verbose > 1;
        $User_DBH ||= DBIx::DBH->connect(%DB_User);
        $User_DBH->do($update_ver_cmd) || die "Couldn't update db_version: $?";
    }
}

if (not $dry_run) {
    print "Databases created successfully.\n";
}

