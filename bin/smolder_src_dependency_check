#!/usr/bin/env perl
use strict;
use warnings;

=pod

=head1 NAME

smolder_src_dependency_check - Check the dependencies of a module in the src/ directory

=head1 SYNOPSIS

    smolder_src_dependency_check --file src/Bit-Vector-6.4.tar.gz

    smolder_src_dependency_check --all

=head1 DESCRIPTION

This list will print a list of all of the modules used by another module, given
the source tarball file.

This list will also give information about whether that dependency is a part of
Perl's CORE or already installed as part of Smolder.

=head1 OPTIONS

=over

=item file

The path of the source tarball in question. This is required if C<--all> is not
specified.

=item all

Indicates that we will examine every module in src. This is required if C<--file> is
not specified.

=item not-ok

Just shows the dependencies that are not found in either the system Perl lib or
in the Smolder Perl lib.

=back

=cut

use File::Spec::Functions qw(catdir catfile splitdir rel2abs canonpath);
use FindBin qw($RealBin);
use Config;

BEGIN {

    # Find a SMOLDER_ROOT based on path to bin
    my @dir = splitdir( canonpath($RealBin) );
    $ENV{SMOLDER_ROOT} ||= catdir( @dir[ 0 .. $#dir - 1 ] );

    # use $SMOLDER_ROOT/lib for modules
    my $lib = catdir( $ENV{SMOLDER_ROOT}, "lib" );
    $ENV{PERL5LIB} =
      $ENV{PERL5LIB}
      ? "$ENV{PERL5LIB}:${lib}"
      : "${lib}";
    unshift @INC, $lib, "$lib/" . $Config{archname};

    # load Smolder
    eval { require Smolder };
    warn << "END" and exit(1) if $@;
######################################################################

Cannot load Smolder.

Error message:

$@

######################################################################
END
}

use Smolder::Conf qw(InstallRoot);
use Module::Depends::Intrusive;
use File::Temp qw(tempdir);
use File::Copy;
use File::Spec::Functions qw(catfile catdir);
use File::Basename;
use Getopt::Long;
use Pod::Usage;

my ( $help, $man, $file, $all, $not_ok );
GetOptions(
    help     => \$help,
    man      => \$man,
    'file=s' => \$file,
    all      => \$all,
    'not-ok' => \$not_ok,
);

pod2usage(1) if $help;
pod2usage( -verbose => 2 ) if $man;
pod2usage("Missing required --file or --all parameter.") unless $file or $all;

if( $file ) {
    my $deps = check_tarball($file);
    display_deps($deps);
} elsif( $all ) {
    my $src_dir = catdir(InstallRoot, 'src');
    my @files = glob("$src_dir/*.tar.gz");
    foreach my $src_file (@files) {
        my $deps = check_tarball($src_file);
        my $header = "Checking $src_file:";
        print $header . "\n" . ( '_' x length($header) ) . "\n"; 
        display_deps($deps);
    }
}
    

sub check_tarball {
    my $src_file = shift;
    # make a temp copy of the tarball
    my $tmpdir = tempdir(
        CLEANUP => 1,
        DIR     => catdir( InstallRoot, 'tmp' ),
    );
    my ( $name, $path, $suffix ) = fileparse( $src_file, '.tar.gz' );
    my $new_file = catfile( $tmpdir, "$name$suffix" );
    copy( $src_file, $new_file ) or die "Could not copy file '$src_file' to '$new_file': $!";

    # untar it
    chdir($tmpdir) or die "Could not change directories to '$tmpdir': $!";
    system("tar -zxvf $new_file 2>&1 > /dev/null") == 0
      or die "Could not untar '$new_file': $@ - $!";

    # get the name of the newly created directory (not every distro does the same thing)
    my $distro_dir;
    opendir( my $DH, $tmpdir ) or die "Could not open directory '$tmpdir': $!";
    while ( my $entry = readdir $DH ) {
        next if $entry =~ /^\./;
        next if $entry =~ /\.tar\.gz$/;
        $distro_dir = $entry;    # should be only one thing in there
        last;
    }
    closedir($DH) or die "Could not close directory '$tmpdir': $!";

    # make it quiet
    my $junk;
    tie( *STDOUT, 'IO::Scalar', \$junk );
    tie( *STDERR, 'IO::Scalar', \$junk );

    my $deps =
      Module::Depends::Intrusive->new->dist_dir( catdir( $tmpdir, $distro_dir ) )
      ->find_modules->requires();

    untie( *STDOUT );
    untie( *STDERR );
    return $deps;
}


sub display_deps {
    my $deps = shift;
    
    # the length of the longest modules name
    my $max_length = 0;
    foreach ( keys %$deps ) {
        $max_length = length($_) if ( length $_ > $max_length );
    }
    my $format = "\%-${max_length}s   => \%-6s (\%s)\n";

    my $failed = 0;
    if ( scalar keys %$deps ) {
        print "\n";
        foreach my $module ( keys %$deps ) {
            next if ( $module eq 'perl' );    # we don't need to verify this
            eval "require $module";
            if ($@) {
                printf( $format, $module, 'NOT OK', 'Not found' );
            } else {
                my $smolder_lib = catdir( InstallRoot, 'lib' );
                my $mod_file = "$module.pm";
                $mod_file =~ s/::/\//g;
                if ( $INC{$mod_file} && $INC{$mod_file} =~ /\Q$smolder_lib\E/ ) {
                    printf( $format, $module, 'OK', 'Found in Smolder lib' )
                        if( ! $not_ok );
                } elsif ( $INC{$mod_file} && $INC{$mod_file} =~ /\Q$Config{sitelib}\E/ ) {
                    printf( $format, $module, 'NOT OK', 'Found in Site lib' );
                    $failed = 1;
                } elsif ( $INC{$mod_file} && $INC{$mod_file} =~ /\Q$Config{vendorlib}\E/ ) {
                    printf( $format, $module, 'OK?', 'Found in Vendor lib' )
                        if( ! $not_ok );
                } elsif ( $INC{$mod_file} && $INC{$mod_file} =~ /\Q$Config{privlib}\E/ ) {
                    printf( $format, $module, 'OK', 'Found in CORE' )
                        if( ! $not_ok );
                } else {
                    printf( $format, $module, 'NOT OK', 'Not found' );
                    $failed = 1;
                }
            }
        }
        if( $not_ok && !$failed ) {
            print "All dependencies OK\n\n";
        } else {
            print "\n";
        }
    } else {
        print "No dependencies.\n\n";
    }
}

