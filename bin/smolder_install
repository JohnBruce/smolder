#!/usr/bin/perl -w
use warnings;
use strict;
use File::Find;
use File::Basename;
use IO::Socket;

# Path to pre-req binaries, filled in by Smolder::Platform->find_bin later
our $PERL_BIN = $^X;
our $COPY_BIN;
our $CHOWN_BIN;
our $CHMOD_BIN;
our $XARGS_BIN;
our $FIND_BIN;
our $MAKE_BIN;
our $ECHO_BIN;
our $TAR_BIN;
our $LN_BIN;
our $DB_PLATFORM;
our $PLATFORM;

$|++;

=head1 NAME

smolder_install - install Smolder from a dist file

=head1 SYNOPSIS

  $ smolder_install

=head1 DESCRIPTION

This script will install Smolder on a *nix system from a dist 
file created by smolder_makedist.

It can also install Smolder from a backup file created by smolder_backup.
For more on this topic, see F<docs/ops_backup.pod>.

=head2 What C<smolder_install> does

Following is a list of the tasks the installer script will perform.

=over 4

=item Check pre-requisites

=over 4

=item IP address must be configured on host.

=item Check for dependencies depending on the DB Platform

=item AdminDBPass must be valid for this box

=item Check for proper version of Perl.

=item InstallPath must NOT exist.

=item Start-up (init.d) script must NOT exist.

=back

=item Create Smolder UNIX user and/or group

=over 4

=item Create with no password (unless user already exists).

=item Use C<useradd>, C<groupadd>, and C<usermod> to manage user account.

=back

=item Install Smolder

=item Configure Smolder

=item Create Database 

=item Create HTML versions of documentation and index them for searching

=item Add Smolder to startup scripts.

=item Start Smolder

=item Make test

=item Output settings and URL of Smolder installation to console.

=back

=head1 OPTIONS

 Required parameters:
  --HostName            - Host name used
  --IPAddress           - IP address used for HTTP

 Optional parameters:
  --Platform            - Installation platform
  --DBPlatform          - The Database platform to use (Default: MySQL)
  --DBUser              - Database user used by Smolder (Default: smolder)
  --DBPass              - Database user password used by Smolder (Default: smolder)
  --DBName              - Database name used by Smolder (Default: smolder)
  --AdminDBPass         - Password for the DB user "root"
  --DBHost              - Host name for DB
  --InstallPath         - Directory for Smolder install (Default: /usr/local/smolder)
  --User                - UNIX user for process ownership (Default: smolder)
  --Group               - UNIX group for process ownership (Default: smolder)
  --ApachePort          - Port on which CMS HTTP server should run (Default: 80)
  --FromAddress         - Email address to use as the From field on outbound messages
  --SMTPHost            - Hostname of the SMTP server to use for sending outbound messages

  --FromBackup          - the name of a backup file to restore from.
  --run-tests           - run Smolder "make test", defaults off
  --help                - Show usage
  --man                 - Show full man page
  --verbose             - Tell me everything

=head1 SEE ALSO

L<smolder_uninstall>, a companion uninstall utility for smolder. 

Refer to F<docs/ops_install.pod>.

=cut

use File::Spec::Functions qw(catdir catfile splitdir rel2abs canonpath);
use FindBin qw($RealBin);
use Config;

# Set up SMOLDER_ROOT and PERL5LIB
BEGIN {

    # Find a SMOLDER_ROOT based on path to bin
    my @dir = splitdir( canonpath($RealBin) );
    $ENV{SMOLDER_ROOT} ||= catdir( @dir[ 0 .. $#dir - 1 ] );

    # use $SMOLDER_ROOT/lib for modules
    my $lib = catdir( $ENV{SMOLDER_ROOT}, "lib" );
    $ENV{PERL5LIB} =
      $ENV{PERL5LIB}
      ? "$ENV{PERL5LIB}:${lib}"
      : "${lib}";
    unshift @INC, $lib, "$lib/" . $Config{archname};
}

use Smolder;
use Smolder::DBPlatform;
use Getopt::Long;
use Pod::Usage;
use HTML::Template;
use File::Temp qw(tempdir);
use File::Copy::Recursive qw(dircopy);

my @original_args = ();
my $uniqueness    = time();
my ( $help, $man, $run_tests );
my @req_params = qw(
  HostName
  IPAddress
);

my @opt_params = qw(
  AdminDBPass
  ApachePort
  DBHost
  DBName
  DBPass
  DBPlatform
  DBUser
  FromAddress
  FromBackup
  Group
  InstallPath
  Platform
  SMTPHost
  User
  verbose
);

my ($backup_dir, $backup_conf);

my %options = ( map { $_ => undef } @req_params, @opt_params );

# if our DBPlatform is MySQL and we didn't specify a DBHost
# make it 'localhost' by default
if( lc $options{DBPlatform} eq 'mysql' ) {
    $options{DBHost} ||= 'localhost';
} 

do_install();
exit(0);

################################
####  MAKE INSTALL METHODS  ####
################################

sub do_install {
    setup_getopts();

    # unpack backup, which contributes to options
    unpack_backup() if $options{FromBackup};

    # enforce requirements
    enforce_requirements();

    # load the plaform module for this distribution
    load_platform($options{Platform});

    # load our database plaform 
    $DB_PLATFORM = Smolder::DBPlatform->load($options{DBPlatform});

    # Do installation
    check_prereqs();

    # working here - must create all users spec'd in backup conf
    create_db_user();
    create_unix_user_group();
    install_smolder();
    configure_smolder();
    create_database();
    finish_install();
    start_smolder();
    make_test() if ($run_tests);
    output_report();
}

# open up the backup file, if one is specified, and load unspecified
# values from the config
sub unpack_backup {

    # open up the backup
    my $bak = $options{'FromBackup'};
    exit_error("FromBackup file '$bak' should end in .bak or .bak.gz")
      unless $bak =~ /\.bak\.gz$/
      or $bak     =~ /\.bak$/;
    exit_error("FromBackup file '$bak' does not exist.")
      unless -e $bak;
    $bak = rel2abs($bak);

    # make temp directory for backup files
    $backup_dir = tempdir(
        CLEANUP => 1,
        DIR     => catdir( $ENV{SMOLDER_ROOT}, 'tmp' )
    );

    print "Unpacking backup file '$bak'.\n";
    my $cmd = "tar -x" . ( $bak =~ /gz$/ ? 'z' : '' ) . "f $bak -C $backup_dir";
    system($cmd) && die("Error un-tarring file '$bak' to '$backup_dir'.\n");
    exit_error("FromBackup file '$bak' is not a valid backup - missing conf/smolder.conf.")
      unless -e catfile( $backup_dir, 'backup', 'conf', 'smolder.conf' );

    # make sure the versions match
    my ($backup_version, $this_version);
    my $ver_file = catfile( $backup_dir, 'backup', 'version' );
    my $VER_FH;
    open($VER_FH, $ver_file) or die "Could not open file '$ver_file': $!";
    $backup_version = <$VER_FH>;
    close($VER_FH);
    chomp($backup_version);
    $this_version = $Smolder::VERSION;
    exit_error(
        "Backup file '$bak' was made with version '$backup_version' of Smolder! "
        . "This is version '$this_version'."
    ) unless $this_version == $backup_version;

    # load configuration file from backup to get defaults
    print "Loading backup configuration.\n";
    require Config::ApacheFormat;
    $backup_conf = Config::ApacheFormat->new();
    $backup_conf->read( catfile( $backup_dir, 'backup', 'conf', 'smolder.conf' ) );

    # load option defaults from conf
    my @backup_options = qw(
      DBUser
      DBName
      User
      Group
      FromAddress
      SMTPHost
    );

    foreach my $opt (@backup_options) {
        $options{$opt} ||= $backup_conf->get($opt);
    }
}

# load the platform module for this dist
sub load_platform {
    exit_error("Can't find data/build.db.  Do you need to run smolder_build?")
      unless -e catfile( $ENV{SMOLDER_ROOT}, 'data', 'build.db' );

    my $platform = shift;

    require Smolder::Platform;

    eval { $PLATFORM = Smolder::Platform->load($platform) };
    if ( $@ ) {
        die "Platform '$platform' is not supported.  "
        . "Available platforms are:\n\n\t"
        . join( "\n\t", @Smolder::Platform::PLATFORMS ) . "\n\n";
    }

    # find paths to binaries
    $COPY_BIN    = $PLATFORM->find_bin( bin => 'cp' );
    $CHOWN_BIN   = $PLATFORM->find_bin( bin => 'chown' );
    $CHMOD_BIN   = $PLATFORM->find_bin( bin => 'chmod' );
    $XARGS_BIN   = $PLATFORM->find_bin( bin => 'xargs' );
    $FIND_BIN    = $PLATFORM->find_bin( bin => 'find' );
    $MAKE_BIN    = $PLATFORM->find_bin( bin => 'make' );
    $ECHO_BIN    = $PLATFORM->find_bin( bin => 'echo' );
    $TAR_BIN     = $PLATFORM->find_bin( bin => 'tar' );
    $LN_BIN      = $PLATFORM->find_bin( bin => 'ln' );
}

sub check_prereqs {
    print "Checking prerequisites\n";

    # check that the platform is set up right.  This will check Perl,
    # GD, the DB and any libraries needed.
    $PLATFORM->verify_dependencies( mode => 'install' );

    # check IP address
    my $IPAddress = $options{'IPAddress'};
    exit_error("IPAddress '$IPAddress' not bound to machine")
      unless $PLATFORM->check_ip( ip => $IPAddress );

    # InstallPath must NOT exist.
    my $InstallPath = $options{InstallPath};
    if ( -e $InstallPath ) {
        if ( -e catfile( $InstallPath, 'bin', 'smolder_uninstall' ) ) {
            exit_error("Will not proceed due to existing Smolder install.")
              unless prompt(
                "y",
"InstallPath '$InstallPath' already exists and seems to contain\nan existing Smolder instance.\nThis program must totally and permanently\nremove this Smolder installation in order to proceed.\n\nIs this what you really want to do?",
                "y/n",
                "n"
              );
            {
                local $ENV{SMOLDER_ROOT} = $InstallPath;
                my $cmd =
                  catfile( $InstallPath, 'bin', 'smolder_uninstall' ) . ' --no_prompt --verbose';
                $cmd .= ' --admin_db_pass=' . $options{AdminDBPass}
                  if length( $options{AdminDBPass} );
                system($cmd)
                  && die(
"Unable to uninstall existing Smolder Instance at $InstallPath.  Please remove this directory manually before running smolder_install again.\n\n"
                  );
            }
        } else {
            exit_error(
"InstallPath '$InstallPath' already exists and does not appear to belong to an existing Smolder instance.  Cannot continue."
            );
        }
    }

    # AdminDBPass must be valid
    my $admin_verified = $DB_PLATFORM->verify_admin(
        passwd => $options{AdminDBPass},
        host   => $options{DBHost},
    );
    unless( $admin_verified ) {
        exit_error("AdminDBPass '$options{AdminDBPass}' is not valid or could not connect to the DB");
    }
}

# sort of simulates Term::Prompt, but not really
sub prompt {

    my ( $yes_val, $prompt_string, $choices, $default_val ) = @_;

    #  if there is a default value, print it
    if ($default_val) {
        print $prompt_string, "($choices)", " [", $default_val, "]: ";
    } else {
        print $prompt_string, "($choices)", ": ";
    }

    $_ = <STDIN>;    # get the input from STDIN

    # remove the newline character from the end of user input
    chomp;

    if ($_) {
        if ( $_ eq $yes_val ) {
            return 1;
        } else {
            return 0;
        }
    } else {
        if ( $default_val eq $yes_val ) {
            return 1;
        } else {
            return 0;
        }
    }
}

sub create_db_user {
    print "Granting DB access to user '$options{DBUser}' for database '$options{DBName}'\n";
    $DB_PLATFORM->create_user(
        admin_passwd => $options{AdminDBPass},
        host         => $options{DBHost},
        user         => $options{DBUser},
        passwd       => $options{DBPass},
        db_name      => $options{DBName},
    );
    print "  DB access granted.\n";
}

sub create_unix_user_group {
    my $gid = $PLATFORM->create_group( options => \%options );
    my $uid = $PLATFORM->create_user( group_id => $gid, options => \%options );
}

sub install_smolder {
    my $InstallPath = $options{InstallPath};
    mkdir($InstallPath) || die($!);

    print "Installing Smolder files into '$InstallPath'\n";

    chdir( $ENV{SMOLDER_ROOT} );
    my $copy = $COPY_BIN . " -r * $InstallPath\/";
    system($copy) && die("Can't copy: $!");

    # remove scripts that won't do anything useful in an installed
    # system
    my @dont_keep = (
        "$InstallPath/bin/smolder_install", "$InstallPath/bin/smolder_makedist",
        "$InstallPath/bin/smolder_upgrade", "$InstallPath/bin/smolder_build",
        "$InstallPath/tmp",
    );
    foreach my $dont_keep (@dont_keep) {
        if ( -d $dont_keep ) {
            system("rm -rf $dont_keep") == 0
              or die "Could not remove $dont_keep! $!";
        } elsif ( -e $dont_keep ) {
            unlink($dont_keep) or die "Could not remove $dont_keep! $!";
        }
    }

    # add some extra directories
    my @add_extras = ( "$InstallPath/tmp", );
    foreach my $add_extra (@add_extras) {
        if ( !-d $add_extra ) {
            mkdir($add_extra) or die "Could not add directory $add_extra! $!";
        }
    }

    # if we have a backup then copy those data files
    if( $options{FromBackup} ) {
        dircopy(
            catdir($backup_dir, 'backup', 'smoke_reports'),
            catdir($InstallPath, 'data', 'smoke_reports'),
        ) or die "Could not copy data from backup: $!";
    }

    print "  Fixing ownership\n";
    my $User  = $options{User};
    my $Group = $options{Group};
    my $chown = $CHOWN_BIN . " -R $User\:$Group $InstallPath";
    system($chown) && die("Can't update ownership: $!");

    # For commands
    my $chmod;

    print "  Setting group write permissions\n";
    $chmod = $CHMOD_BIN . " -R g+w $InstallPath";
    system($chmod) && die("Can't set group write permissions: $!");

    print "  Fixing file read permissions\n";
    $chmod = $CHMOD_BIN . " -R +r $InstallPath";
    system($chmod) && die("Can't fix file read permissions: $!");

    print "  Fixing directory read permissions\n";
    $chmod = $FIND_BIN . " $InstallPath -type d | " . $XARGS_BIN . " " . $CHMOD_BIN . " +rx";
    system($chmod) && die("Can't fix directory read permissions: $!");

    print "  Setting #! on scripts to " . $PERL_BIN . "\n";
    opendir( DIR, catdir( $InstallPath, "bin" ) ) or die $!;
    my @scripts = grep { -f $_ }
      map { catfile( $InstallPath, "bin", $_ ) } readdir(DIR);
    closedir DIR;
    foreach my $script (@scripts) {
        my $basename = basename($script);
        next if ( $basename =~ /^\./ );    # parental controls
        open( SOURCE, $script ) or die "Unable to $script: $!";
        my $source = do { local $/; <SOURCE> };

        $source =~ s/^#!.*$/#!$PERL_BIN/m
          or die "Couldn't find shebang line in $script to replace!";

        open( SOURCE, '>', $script ) or die "Unable to write $script: $!";
        print SOURCE $source;
        close SOURCE;
    }

    # Set all files in Smolder/bin/*
    $chmod = $CHMOD_BIN . " +x $InstallPath/bin/*";
    system($chmod) && die("Can't set execute bits: $!");

    print "  Smolder files installed.\n";
}

sub configure_smolder {
    print "Configuring Smolder installation\n";

    my $InstallPath = $options{InstallPath};
    chdir($InstallPath);

    if ( $options{FromBackup} ) {
        print "Updating backup smolder.conf\n";

        # processing existing smolder.conf, replacing IPAddress and
        # HostName parameters needed to migrate a backup to a new machine
        open( CONF, "<", "conf/smolder.conf" )
          or die "Unable to open conf/smolder.conf : $!";
        my @conf = <CONF>;
        close(CONF);

        open( CONF, ">", "conf/smolder.conf" )
          or die "Unable to open conf/smolder.conf : $!";
        foreach my $line (@conf) {
            if ( $line =~ /^\s*ApacheAddr\s/i ) {
                print CONF "ApacheAddr $options{IPAddress}\n";
            } elsif ( $line =~ /^\s*HostName\s/i ) {
                print CONF "HostName $options{HostName}\n";
            } else {
                print CONF $line;
            }
        }
        close CONF;

    } else {

        # Make custom smolder.conf
        print "Creating smolder.conf from specification\n";
        my $t = HTML::Template->new(
            filename          => $ENV{SMOLDER_ROOT} . "/conf/smolder.conf.tmpl",
            die_on_bad_params => 0,
        );
        foreach my $param ( keys(%options) ) {
            $t->param( $param => $options{$param} );
        }

        # add a unique secret for this install
        $t->param(Secret => _random_secret() );

        my $output_conf = $InstallPath . "/conf/smolder.conf";
        open( OUTPUT, ">$output_conf" ) || die("Can't open '$output_conf' for writing: $!");
        print OUTPUT $t->output();
        close(OUTPUT);
    }

    print "  Conf written to '$InstallPath/conf/smolder.conf'.\n";
}

sub create_database {
    my $InstallPath = $options{InstallPath};
    chdir($InstallPath);

    if ( $options{FromBackup} ) {

        # load database SQL
        my $sql_bak = catfile($backup_dir, 'backup', 'dump.sql');
        $DB_PLATFORM->run_sql_file(
            file         => $sql_bak, 
            admin_passwd => $options{AdminDBPass},
            host         => $options{DBHost},
        );
    } else {

        # Create DB
        print "Creating Database and loading schema\n";
        my $AdminDBPass = $options{'AdminDBPass'};
        my $DBHost      = $options{'DBHost'};
        my $createdb    = "SMOLDER_ROOT='' PERL5LIB='' $InstallPath/bin/smolder_createdb --destroy";
        $createdb .= " --AdminDBPass $options{AdminDBPass}"       if ( length($options{AdminDBPass}) );
        $createdb .= " --DBHost $options{'DBHost'}" if ( defined($DBHost) );
        system($createdb) == 0
          or die("Error calling smolder_createdb.  Unable to continue");
    }
}

# "finishing" typically involves installing a control script
# that gets run at startup/shutdown time to manage the service.
sub finish_install {
    $PLATFORM->finish_installation( options => \%options );
}

sub start_smolder {
    my $InstallPath = $options{InstallPath};
    print "Starting Smolder via $InstallPath/bin/smolder_ctl\n";
    my $start = "SMOLDER_ROOT='' PERL5LIB='' $InstallPath/bin/smolder_ctl start";
    system($start) && die("Can't start Smolder: $!");
}

sub make_test {
    print "Running Smolder tests...\n";

    my $InstallPath = $options{InstallPath};
    chdir($InstallPath);

    my $make_bin  = $MAKE_BIN;
    my $make_test = "SMOLDER_ROOT='' PERL5LIB='' $make_bin test";
    system($make_test) && die("Error running tests: $!");
}

sub output_report {
    $PLATFORM->post_install_message( options => \%options );
}

###########################
####  PRIVATE METHODS  ####
###########################

sub exit_error {
    my $cmd = $0;
    $cmd =~ s/.*\/(.+)$/$1/;

    my $message = shift;
    print STDERR "\nError: $cmd:  $message\n\n";
    exit(1);
}

sub setup_getopts {

    # Copy the original args for re-invoking later
    @original_args = @ARGV;

    GetOptions(
        'help'      => \$help,
        'man'       => \$man,
        'run-tests' => \$run_tests,
        ( map { $_ . "=s" => \$options{$_} } @req_params, @opt_params )
      )
      || pod2usage(2);

    pod2usage(1) if $help;
    pod2usage( -verbose => 2 ) if $man;

}

sub enforce_requirements {

    # Enforce required params
    my $error_output = "";
    foreach my $p (@req_params) {
        next if defined( $options{$p} );
        $error_output .= "Missing --" . $p . "\n";
    }
    if ($error_output) {
        print "Error:\n\n$error_output\n";
        pod2usage(1);
    }

    # Set opt defaults
    set_param_defaults();
}

sub set_param_defaults {
    my %defaults = (
        AdminDBPass => '',
        InstallPath => '/usr/local/smolder',
        User        => 'smolder',
        Group       => 'smolder',
        ApachePort  => '80',
        DBName      => 'smolder',
        DBUser      => 'smolder',
        DBPass      => 'smolder',
        DBPlatform  => 'SQLite',
    );

    # Set up defaults if value is not otherwise set
    while ( my ( $k, $dv ) = each(%defaults) ) {

        # Skip if value already defined
        next if ( defined $options{$k} );

        # Set default
        $options{$k} = $dv;
    }
}

sub _random_secret {
    my $length = int(rand(10) + 20);
    my $secret = '';
    my @chars = ('a'..'z', 'A'..'Z', 0..9, qw(! @ $ % ^ & - _ = + | ; : . / < > ?));
    $secret .= $chars[int(rand($#chars + 1))] for(0..$length);
    return $secret;
}


